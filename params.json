{"name":"gws","tagline":"A helper to manage workspaces composed of git repositories.","body":"gws\r\n===\r\n\r\n`gws` is a KISS, bash, colorful helper to manage workspaces composed of git\r\nrepositories.\r\n\r\nSHOW ME PICTURES!\r\n-----------------\r\n\r\nHere are some screen captures of `gws`:\r\n\r\n![gws](http://streakycobra.github.io/gws/images/001.png)\r\n\r\n![gws](http://streakycobra.github.io/gws/images/002.png)\r\n\r\n![gws](http://streakycobra.github.io/gws/images/003.png)\r\n\r\n![gws](http://streakycobra.github.io/gws/images/004.png)\r\n\r\n![gws](http://streakycobra.github.io/gws/images/005.png)\r\n\r\nInstallation\r\n------------\r\n\r\n**Requirements:** `git`, `bash > 4.0`\r\n\r\n* **Arch Linux**: Install the [gws](https://aur.archlinux.org/packages/gws/)\r\n  package from AUR\r\n\r\n* **openSUSE**: Install the [gws](https://software.opensuse.org/package/gws/)\r\n  package from the devel:tools repository\r\n\r\n* **Other Linux/Mac**: You simply need to have the `src/gws` bash script\r\n  somewhere inside your `$PATH`:\r\n\r\n  * If someone made a package for your distribution you are lucky.\r\n\r\n  * You can put it directly in `/bin` as root user, but it is complicated to\r\n    keep it up-to-date.\r\n\r\n  * It is also possible to put it in your home folder, for example in\r\n    `~/.local/bin`. You have to be sure that this folder is in your `$PATH`. For\r\n    `bash` you can include any directory on your `$PATH` by including `export\r\n    PATH=\"$PATH:/path/to/scripts/dir\"` in your `~/.bashrc` file.\r\n\r\n  * On Mac OS X, it may be necessary to upgrade bash to have a version `> 4.0`.\r\n    It could be done with: `brew install bash`.\r\n\r\nOn a side note, I could also suggest you to have a look at\r\n[peru](https://github.com/buildinspace/peru) which permits to keep files from\r\ndifferent sources up to date with one command.\r\n\r\nQuickStart\r\n----------\r\n\r\n* Create a file named `.projects.gws` in a desired workspace folder (e.g.\r\n  `~/dev`) and fill it with the projects informations (see\r\n  [Syntaxes below](#projectsgws)):\r\n\r\n        # Work related\r\n        work/tools/q | https://github.com/harelba/q.git\r\n\r\n        # Other\r\n        contrib/gws  | https://github.com/StreakyCobra/gws.git\r\n        contrib/peru | https://github.com/buildinspace/peru\r\n\r\n**or**\r\n\r\n* Let it detect existing repositories and create the `.projects.gws` for you\r\n  with:\r\n\r\n        $ cd path/to/your/workspace\r\n        $ gws init\r\n\r\n**and then**\r\n\r\n* Clone all missing repositories with `gws update`.\r\n\r\n* Do some hacking.\r\n\r\n* Show the status of the workspace with `gws`. It reveals which repositories are\r\n  clean, which ones have uncommited changes, or even to know which ones are not\r\n  up-to-date with `origin`.\r\n\r\n### But better\r\n\r\nLet's say you made a `~/dev/` workspace folder and you created your\r\n`.project.gws` list in it. Then your workspace became really easy to replicate!\r\nJust make this `~/dev` folder a git repository, add two files and commit them:\r\n`.projects.gws` and the following `.gitignore`:\r\n\r\n    # Ignore everything, so all repositories in our case\r\n    *\r\n\r\n    # But no these files\r\n    !.projects.gws\r\n    !.gitignore\r\n\r\nNow, when you need to get your workspace on another computer, just clone\r\nthe `dev` repository, for instance again to the `~/dev` folder. Go into it and\r\ndo a `gws update`. Everything is cloned and ready to be hacked!\r\n\r\nYou want to add a new project into your workspace? Add it to the `.projects.gws`\r\nlist, do a `gws update` to get it. Then commit and push the `.projects.gws`\r\nfile, so when you arrive at work for instance, you just need to do `git pull` on\r\nthe `~/dev` folder and then `gws update` to find the same workspace structure\r\nthat you where having at home.\r\n\r\nWhy?\r\n----\r\n\r\nIf you are, like me, a Linux programmer/hacker/coder who uses heavily git, you\r\ncertainly have a directory in your home folder named `dev`, `workspace`, `code`\r\nor something else that contains all the projects you are working on. For\r\ninstance my current organisation is:\r\n\r\n    dev\r\n    ├── archlinux\r\n    │   ├── aur\r\n    │   └── habs\r\n    ├── perso\r\n    │   ├── gws\r\n    │   ├── imaxplore\r\n    │   └── teafree\r\n    ├── config\r\n\r\nwhere `aur`, `habs`, `gws`, `imaxplore`, `teafree`, `config` are git\r\nrepositories.\r\n\r\nSince I use at least three different computers, one laptop, one at home and one\r\nat work, I like to have the same folder structure on all of them. Of course\r\nremembering which project was added recently on others computer and in which\r\nfolder is tedious.\r\n\r\nSo I started to thing about using git submodules to register all projects on\r\nwhich I am working and syncing them with git between the two computers. But\r\nclearly git submodules are not usable because they are working on specific\r\ncommit and are not following branches.\r\n\r\nNo worry. The problem is pretty trivial, so I decided to start write a little\r\nbash (YOLO) script that read a simple list of repositories, and clone them if\r\nthey don't exist. And then, commit by commit, the script as grown to finally\r\nbecome a helper to sync, monitor and check workspaces.\r\n\r\nI thought it can be useful to other people, so I made a little cleanup, write a\r\nsmall documentation, and there it is. I hope you will enjoy it!\r\n\r\nFunctionalities\r\n---------------\r\n\r\nThis tool offers some functionalities, among which:\r\n\r\n* It uses a list of projects, named `.projects.gws`, containing many projects\r\n  described by their names, their repository urls, and optionaly an upstream\r\n  url (mapped as a git remote named `upstream`), like:\r\n\r\n        work/theSoftware | git@github.com:You/theSoftware.git\r\n        perso/gws        | git@github.com:You/gws.git         | git@github.com:StreakyCobra/gws.git\r\n\r\n* It can use an ignore list, named `.ignore.gws`, containing regular\r\n  expressions which discard some specific projects, for instance to disable on\r\n  your home computer the work-related projects.\r\n\r\n        ^work/\r\n\r\n* It can detect already existing repositories and create the projects list\r\n  from that.\r\n\r\n        $ gws init\r\n\r\n* It can clone non-existing repositories from the projects list (but not\r\n  supress them in case of removal, you have to do it yourself for safety\r\n  reason. Notice that there is the `check` functionnality to identify\r\n  those unlisted repositories).\r\n\r\n        $ gws update\r\n\r\n* It can monitor all listed repositories in one command (uncommitted changes,\r\n  untracked changes, branches not synced with origin, ...).\r\n\r\n        $ gws status\r\n\r\n  or simply\r\n\r\n        $ gws\r\n\r\n* It can fetch the modifications from `origin` for all repositories, it is\r\n  usefull te be sure to have the latest modifications, for instance before\r\n  going to take the train with no internet connection:\r\n\r\n        $ gws fetch\r\n\r\n* It can also (for the same reasons) pull the modifications from origin for\r\n  all repositories (but fast-forward only). Syntactic sugar to avoid a `gws\r\n  fetch` and then many merges:\r\n\r\n        $ gws ff    # Mnemonic: ff=fast-forward\r\n\r\n* It can check the workspace for all repositories (known, unknown, ignored,\r\n  missing). Note: This command can be quite slow in large repositories (e.g.\r\n  home folder, because it need to search entire space for unknown repository.\r\n  Mainly used from time to time to check consistence of the workspace:\r\n\r\n        $ gws check\r\n\r\n\r\nSyntaxes\r\n--------\r\n\r\n### .projects.gws\r\n\r\nOne project per line. Must be of the form:\r\n\r\n    <any/folder/path> | <remote_url1> <remote_name1> [ | <remote_url2> <remote_name2> [ |  ... ]]\r\n\r\nknowing that:\r\n\r\n* The `<remote_name1>` can be skipped and `origin` will be used instead\r\n\r\n* The `<remote_name2>` can be skipped and `upstream` will be used instead\r\n\r\n* There must be at least one `<remote_name>` mapping to `origin`\r\n\r\n* There can also be blank lines, comments or inline comments. Comments start\r\n  with `#` until the end of the line.\r\n\r\n* The *folder paths* can be any valid linux folder path not containing `|`, `#`\r\n  or spaces.\r\n\r\n* The *remote names* can be any string not containing `|`, `#` or spaces.\r\n\r\n* The *remote urls* are passed to git as-is, so can be anything accepted by git,\r\n  but must not contain `|`, `#` or spaces. For instance if you have SSH aliases\r\n  in your config they are accepted.\r\n\r\n### .ignore.gws\r\n\r\nOne regular expression per line. The regular expression will be matched to\r\nprojects name. Some examples:\r\n\r\n* Ignore the folder `work` and all its subfolders:\r\n\r\n        ^work/\r\n\r\n* Ignore all repositories ending with `-work`:\r\n\r\n        -work$\r\n\r\n* Ignore all repo containing an `a` inside:\r\n\r\n        a\r\n\r\nThis function is really usefull for ignoring locally some projects that are not\r\nneeded nor accessible.\r\n\r\nOther thoughts\r\n--------------\r\n\r\n* Except for cloning repositories, this script has not for goal to interact\r\n  with your repositories. So no `pull all`, `push all`, `delete all unused`,\r\n  functionnality will be implemented (except fast-forward). This will imply too\r\n  much checking to ensure no loose of informations. Instead, just look the satus\r\n  of the repositories and do needed actions manually on regular basis.\r\n\r\n* You can use the commands from any subfolder of the workspace (as `git` does\r\n  for instance).\r\n\r\n* The file `.projects.gws` can easily be verisonned to sync the list of\r\n  projects on which you are working between different computers.\r\n\r\n* The file `.ignore.gws` permit to keep the same `.projects.gws` list on all\r\n  computer, but to localy disable some projects (for instance work-related\r\n  projects at home because they are unneeded or even not accessible from\r\n  there).\r\n\r\n* `gws check` can be quite slow (for instance if the workspace is the home\r\n  folder) because it searches all existing git projects recursively.\r\n\r\nFuture\r\n------\r\n\r\nThis project aims to stay simple. I will try to keep the project as alive as\r\npossible for a bash script, by correcting bugs and maybe some improvements.\r\nAlso, maybe one day, if I have time, I will rewrite all this script in python or\r\nother more maintainable language.\r\n\r\n*Edit:* It seems there will be a continuation of this idea, and it will be\r\nwritten in OCaml! I'll let you know if the project maturate! In any case this\r\nproject will stay here for users who want something simple and portable.\r\n\r\nContributors\r\n------------\r\n\r\nMany thanks to these people for contributions:\r\n\r\n- Frédéric Mahé\r\n- Blount\r\n- Alex Sanchez\r\n- Antoine Belvire\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}